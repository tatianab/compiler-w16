/* File: RegAllocator.java
 * Authors: Tatiana Bradley and Wai Man Chan
 * Winter 2016
 * CS 241 - Advanced Compiler Design
 */
import java.util.ArrayList;
import java.util.Stack;

public class CodeGenerator {
	/* The code generator's responsibility is to emit native programs in DLX format
	   after optimizations and register allocation.

	   Information about DLX processor

	   Registers:
	   32 general purpose 32-bit registers R0 - R31.
	   R0 always contains 0.
	   Branch instructions to subroutinges implicitly use R31 to store return address.

	   Program loader:
	   Object file has no header or footer.
	   End of program signaled by RET 0.

	 */
	IntermedRepr        program;
	InstructionSchedule schedule; // The instructions to translate.
	ArrayList<DlxOp>    dlxOps;   // The DLX instructions we have generated so far.
	int[]               byteCode;
	boolean             debug;

	int nextDlxPos;
	Instruction currentInstruction;
	Block       currentBlock;


	// TODO: associate assembly instructions with containing block and function.

	public static final int ZERO     = 0;  // R0 always stores the value 0.
	public static final int SCRATCH  = 1;  // R1 is the scratch register to hold intermediate values.
	public static final int SCRATCH2 = 2;  // R2 is the second scratch register.
	public static final int FP       = 29; // Frame pointer is R29.
	public static final int SP       = 28; // Stack pointer is R28.
	public static final int GLOBALS  = 30; // R30 stores a pointer to global vars.
	public static final int RET_ADDR = 31; // R31 is used to store the return address of subroutines.

	public static final int BYTES_IN_WORD = 4;
	public static final int IMM_OFFSET    = 16; // The offset for immediate ops.



	public CodeGenerator(IntermedRepr program, InstructionSchedule schedule, boolean debug) {
		this.program  = program;
		this.schedule = schedule;
		this.dlxOps   = new ArrayList<DlxOp>();
		this.debug    = debug;
		this.nextDlxPos = 0;
	}

	// Wrapper function for generation of code.
	public void generateCode() {
		// Do any initial setup.
		setUpMemory();

		// Generate code from instructions.
		translateInstructions();

		// Signal the end of the program.
		endProgram();
	}

	// Run the DLX code generated by this class.
	public void runGeneratedCode() {
		try {
			DLX.load(byteCode);
			DLX.execute();
			System.out.println();
		} catch (Exception e) {
			Compiler.error("Program could not be run.");
		}
	}

	// Allocate space for global variables and
	// set the stack pointer and frame pointer for
	// the main function.
	public void setUpMemory() {
		// Allocate space for global variables.
		addInstruction(DLX.ADDI, GLOBALS, ZERO, (DLX.MemSize / BYTES_IN_WORD) - BYTES_IN_WORD);
		// Set up stack pointer and frame pointer.
		addInstruction(DLX.SUBI, SP, GLOBALS, program.getNumGlobals() * BYTES_IN_WORD);
		addInstruction(DLX.ADDI, FP, SP, 0); // Set SP == FP.
	}

	// Signal the end of the program.
	public void endProgram() {
		fixBranches();
		byteCode = new int[dlxOps.size()];
		int i = 0;
		for (DlxOp instr : dlxOps) {
			byteCode[i] = getNativeInstr(instr);
			i++;
		}
	}

	/* Methods related to translating instructions to DLX code. */

	void translateInstructions() {
		// TODO: handle functions.
		InstructionSchedule.ScheduledBlock block = schedule.mainBlock;
		Stack<InstructionSchedule.ScheduledBlock> workList = new Stack<InstructionSchedule.ScheduledBlock>();
		workList.push(block);

		// Iterate over the blocks, making sure block code is generated
		// in the correct order.
		while(!workList.empty()) {
			block = workList.pop();
			// Handle translation of the block.
			generateBlock(block);
			// Fall through should be generated before
			// jump, so push jump on the stack first.
			if (block.next2 != null && !block.next2.compiled) {
				workList.push(block.next2);
			}
			if (block.next1 != null && !block.next1.compiled) {
				workList.push(block.next1);
			}
		}
	}

	// Generate code for a single block.
	void generateBlock(InstructionSchedule.ScheduledBlock block) {
		block.compiled = true;
		currentBlock = block.referenceBlock;
		if (Compiler.debug) {
			System.out.println("Translating block " + currentBlock.shortRepr());
		}
		for (InstructionSchedule.outputInstruction instr : block.instructions) {
			translateInstruction(instr);
		}
	}

	// Generate the DLX instruction(s) corresponding to the given instruction.
	void translateInstruction(InstructionSchedule.outputInstruction instr) {
		if (Compiler.debug) {
			System.out.println("Translating instruction " + instr);
		}

		int op, dlxOp;
		int arg1, arg2;
		int numArgs = 0;

		op = instr.op;

		// Handle special cases.
		switch (op) {
			case call: // Function call
			 generateFunctionCall(instr);
			 return;
			case move:
			 generateMove(instr);
			 return;
			case Instruction.arrayLoad:
			 Compiler.warning("Arrays not handled.");
			 return;
			case Instruction.arrayStore:
			 Compiler.warning("Arrays not handled.");
			 return;
			case phi:
			 Compiler.warning("Phi not allowed.");
			 return;
			default:
			 // Nothing.
		}

		// Grab the appropriate DLX operation and the number of arguments.
		dlxOp   = opLookup(op);
		numArgs = numArgs(op);

		// Instructions with no arguments.

		if (numArgs == 0) {
			addInstruction(dlxOp);
		}

		// Instructions with one argument.

		else if (numArgs == 1) {
			switch (op) {
				case end:
					arg1 = ZERO;
					break;
				case read:
					arg1 = loadValue(instr, 0, SCRATCH);
					break;
				case write:
					arg1 = loadValue(instr, 1, SCRATCH2);
					break;
				default:
				 Compiler.warning("Argument not found.");
				 arg1 = -1;
			}

			addInstruction(dlxOp, arg1);
		}


		// Instructions with two arguments (branching instructions).

		else if (numArgs == 2) {

			// Handle load and store.
			if (op == load || op == store) {
				// addInstruction(dlxOp, dest, arg1);
				return;
			}

			// Unconditional branch is "jump if register 0 contains 0", which is
			// always true.
			if (op == bra) {
				arg1 = ZERO;
			} else {
				arg1 = loadValue(instr, 1, SCRATCH);
			}

			Block branch = instr.jumpBlock;

			// If the block to branch to is empty, keep going until a non-empty block
			// is found.
			while (branch.schedule.isEmpty()) {
				branch = branch.schedule.next1.referenceBlock;
			}

			if (branch == null) {
				Compiler.error("Branch cannot be null for branching instruction.");
			}

			addInstruction(dlxOp, arg1, branch);
		}

		// Instructions with three arguments.

		else if (numArgs == 3) {
			int dest = loadValue(instr, 0, SCRATCH);
			arg1 = loadValue(instr, 1, SCRATCH);

			// Use the immediate operator if the second argument is a constant.
			if (instr.arg2 == -1) {
				dlxOp += IMM_OFFSET;
				arg2 = instr.constant2;
			} else {
				arg2 = loadValue(instr, 2, SCRATCH2);
			}

			addInstruction(dlxOp, dest, arg1, arg2);
		}

	}

	// Convert argument of any type to a register.
	// Inputs: instr (containing instruction)
	//         argNum - 0 is dest, 1 is arg1, 2 is arg2.
	//         scratch - the scratch register to load into if necessary.
	int loadValue(InstructionSchedule.outputInstruction instr, int argNum, int scratch) {
		// If the argument is a constant, load it into the scratch register.
		boolean isConstant = false;
		int reg   = -1;
		int constant = 0;

		// Get the appropriate register of constant.
		switch (argNum) {
			case 0:
				if (instr.outputReg != -1) {
					reg = instr.outputReg;
				} else {
					Compiler.error("No destination register assigned.");
				}
				break;
			case 1:
			 if (instr.arg1 != -1) {
				 reg = instr.arg1;
			 } else {
				 isConstant = true;
			 	 constant = instr.constant1;
			 }
			 break;
			case 2:
				if (instr.arg2 != -1) {
					reg = instr.arg2;
				} else {
					isConstant = true;
					constant = instr.constant2;
				}
				break;
			default:
			 Compiler.error("Invalid argument.");
		}

		// Load into register if a constant.
		if (isConstant) {
			addInstruction(DLX.ADDI, scratch, ZERO, constant);
			reg = scratch;
		}

		// Return final register.
		return reg;
	}

	public void generateMove(InstructionSchedule.outputInstruction instr) {
		// TODO
	}

	public void generateFunctionCall(InstructionSchedule.outputInstruction instr) {
		// TODO
	}

	/* End methods related to translating instructions to DLX code. */

	public void fixBranches() {
		for (DlxOp dlxOp : dlxOps) {
			if (dlxOp.branch != null) {
				if (Compiler.debug) {
					System.out.println("Fixing " + dlxOp);
				}
				if (dlxOp.branch.dlxPos != null) {
					dlxOp.setOffset(dlxOp.branch.dlxPos - dlxOp.pos);
				} else {
					dlxOp.setOffset(0);
					Compiler.warning("No offset available for block " +
						dlxOp.branch.shortRepr());
				}
				if (Compiler.debug) {
					System.out.println("Now " + dlxOp);
				}
			}
		}
	}

	public class DlxOp {
		public int op;
		public int pos; // Where in the final program this instr will live.
		public Integer arg1;
		public Integer arg2;
		public Integer arg3;
		public Block branch;

		// Auxillary info for debugging.
		public Instruction instr; // The corresponding SSA instr.
		public Block       block; // If this is the beginning of a block.

		public DlxOp(int op, Integer arg1, Integer arg2, Integer arg3) {
			this.op     = op;
			this.arg1   = arg1;
			this.arg2   = arg2;
			this.arg3   = arg3;
			this.branch = null;
			this.pos    = nextDlxPos;
			nextDlxPos++;
			this.instr  = currentInstruction;
			if (currentBlock != null) {
				this.block = currentBlock;
				currentBlock.dlxPos = pos;
				currentBlock = null;
			} else {
				this.block = null;
			}
		}

		// This instruction will need to be fixed once it is known where
		// the block to jump to lives.
		public DlxOp(int op, Integer compare, Block branch) {
			this.op = op;
			this.arg1   = compare;
			this.arg2   = null;
			this.arg3   = null;
			this.branch = branch;
			this.pos    = nextDlxPos;
			nextDlxPos++;
			this.instr  = currentInstruction;
			if (currentBlock != null) {
				this.block = currentBlock;
				currentBlock = null;
			} else {
				this.block = null;
			}
		}

		public void setOffset(int offset) {
			if (this.arg1 == null) {
				this.arg1 = offset;
			} else {
				this.arg2 = offset;
			}
		}

		@Override
		public String toString() {
			return DLX.mnemo[op] + " " + arg1 + " " + arg2 + " " + arg3;
		}
	}

	// Add instruction to the program after it has been converted to a low level
	// representation.
	public void addInstruction(int op, int a, int b, int c) {
		dlxOps.add(new DlxOp(op, a, b, c));
	}

	public void addInstruction(int op, int a, int c) {
		dlxOps.add(new DlxOp(op, a, c, null));
	}

	public void addInstruction(int op, int c) {
		dlxOps.add(new DlxOp(op, c, null, null));
	}

	public void addInstruction(int op) {
		dlxOps.add(new DlxOp(op, null, null, null));
	}

	public void addInstruction(int op, int a, Block branch) {
		dlxOps.add(new DlxOp(op, a, branch));
	}

	// Convert assembly to byte code.
	public int getNativeInstr(DlxOp instr) {
		if (debug) { System.out.println("Generating native code for " + instr + "(" + instr.instr + ")"); }
		int op = instr.op;
		Integer arg1, arg2, arg3;
		arg1 = instr.arg1;
		arg2 = instr.arg2;
		arg3 = instr.arg3;

		int result;
		if (arg1 == null) {
			result = DLX.assemble(op);
		} else if (arg2 == null) {
			result = DLX.assemble(op, arg1);
		} else if (arg3 == null) {
			if (debug) { System.out.println(" (Two arg)"); }
			result = DLX.assemble(op, arg1, arg2);
		} else {
			result = DLX.assemble(op, arg1, arg2, arg3);
		}

		if (debug) { System.out.println("Generated " + DLX.disassemble(result)); }
		return result;
	}

	public void addInstruction(Instruction instr) {
		if (debug) { System.out.println("Translating instruction " + instr); }
		// If the instruction is the first in its block, the position
		// of this instruction will mark the beginning of the block's code.
		int op = instr.op;

		if (instr.prev == null) {
			instr.block.dlxPos = nextDlxPos;
		}
		switch(op) {
			case Instruction.phi:
				Compiler.warning("No phis allowed!");
				return;
			case Instruction.end:
				addInstruction(DLX.RET, 0);
				return;
			case Instruction.call:
				generateFunction(instr);
				return;
			default:
				break;

		}

		if (op >= Instruction.neg && op <= Instruction.adda) {
			generateComputation(instr);
		} else if (op >= Instruction.load && op <= Instruction.move) {
			generateLoadStore(instr);
		} else if (op == Instruction.bra || (op >= Instruction.bne && op <= Instruction.ble)) {
			generateBranch(instr);
		} else if (op >= Instruction.read && op <= Instruction.writeNL) {
			generateIO(instr);
		} else if (op == Instruction.arrayStore || op == Instruction.arrayLoad) {
			generateArrayOp(instr);
		} else {
			Compiler.error("Invalid instruction " + instr);
		}
	}

	// Deal with intructions like add, mul, sub, div etc.
	// Return true if successful.
	public boolean generateComputation(Instruction instr) {
		// Add 16 to opcode to get immediate instruction.
		int dlxOp, immOp;
		int dstReg = instr.getReg(); // Where the result goes.
		Value arg1 = instr.arg1;
		Value arg2 = instr.arg2;

		// TODO: what if arg1 or arg2 are stored in memory rather than registers?

		switch(instr.op) {
			case Instruction.neg:
				dlxOp = DLX.SUB;
				arg2  = arg1;
				arg1  = new Constant(0);
				break;
			case Instruction.add:
				dlxOp = DLX.ADD;
				break;
			case Instruction.adda:
				dlxOp = DLX.ADD;
				// TODO: handle address adding
				break;
			case Instruction.sub:
				dlxOp = DLX.SUB;
				break;
			case Instruction.mul:
				dlxOp = DLX.MUL;
				break;
			case Instruction.div:
				dlxOp = DLX.DIV;
				break;
			case Instruction.cmp:
				dlxOp = DLX.CMP;
				break;
			default:
				return false;
		}

		immOp = dlxOp + 16; // The immediate operation.

		if (arg1.getReg() >= 0 && arg2.getReg() >= 0) {                    // Both args have registers.
			if (debug) { System.out.println("Computation: Neither arg constant.");}
			addInstruction(dlxOp, dstReg, arg1.getReg(), arg2.getReg());
		} else if (arg1 instanceof Constant && arg2 instanceof Constant) { // Neither have registers.
			if (debug) { System.out.println("Computation: Both args constant.");}
			addInstruction(DLX.ADDI, SCRATCH, ZERO, arg1.getVal());
			addInstruction(immOp, dstReg, SCRATCH, arg2.getVal());
		} else if (arg1 instanceof Constant) {                             // Just first has a register.
			if (debug) { System.out.println("Computation: 1st arg constant.");}
			addInstruction(DLX.ADDI, SCRATCH, ZERO, arg1.getVal());
			addInstruction(dlxOp, dstReg, SCRATCH, arg2.getReg());
		} else if (arg2 instanceof Constant) {                             // Just second has a register.
			if (debug) { System.out.println("Computation: 2nd arg constant.");}
			addInstruction(immOp, dstReg, arg1.getReg(), arg2.getVal());
		} else {
			Compiler.error("Invalid arguments to instruction " + instr);
		}

		return true;
	}

	public boolean generateBranch(Instruction instr) {
		int dlxOp;
		Value compare = instr.arg1;
		int compareReg = compare.getReg();
		Block jumpTo  = (Block) instr.arg2;

		switch (instr.op) {
			case Instruction.bne:
				dlxOp = DLX.BNE;
				break;
			case Instruction.beq:
				dlxOp = DLX.BEQ;
				break;
			case Instruction.bge:
				dlxOp = DLX.BGE;
				break;
			case Instruction.blt:
				dlxOp = DLX.BLT;
				break;
			case Instruction.bgt:
				dlxOp = DLX.BGT;
				break;
			case Instruction.ble:
				dlxOp = DLX.BLE;
				break;
			case Instruction.bra:
				dlxOp = DLX.BEQ; // Unconditional branch.
				compare = (Value) null;
				compareReg = ZERO;
				jumpTo = (Block) instr.arg1;
				break;
			default:
				return false;
		}


		if (compare instanceof Constant) {
				addInstruction(DLX.ADDI, SCRATCH, ZERO, compare.getVal());
				addInstruction(dlxOp, SCRATCH, jumpTo);
		} else {
				addInstruction(dlxOp, compareReg, jumpTo);
		}
		return true;

	}

	public boolean generateLoadStore(Instruction instr) {
		// This currently only works for move instructions.
		int dlxOp;
		int dstReg = instr.getReg();
		int srcReg = -1;
		switch(instr.op) {
			case Instruction.load :
				// DLX.LDW R.a = Mem[R.b + c]
				// DLX.LDX R.a = Mem[R.b + R.c]
				break;
			case Instruction.store:
				// DLX.STW, DLX.STX
				break;
			case Instruction.move :
				// load then store
				// or add dst 0 src
			    srcReg = instr.arg1.getReg();
				break;
			default:
				return false;
		}

		if (instr.arg1 instanceof Constant) {
			addInstruction(DLX.ADDI, SCRATCH, ZERO, instr.arg1.getVal());
			srcReg = SCRATCH;
		}
		addInstruction(DLX.ADD, dstReg, ZERO, srcReg);
		return true;
	}

	public void generateArrayOp(Instruction instr) {
		// TODO
	}

	public boolean generateIO(Instruction instr) {
		int dlxOp;
		Value arg = null;
		switch(instr.op) {
			case Instruction.read   :
				dlxOp = DLX.RDI;
				arg   = instr;
				break;
			case Instruction.write  :
				dlxOp = DLX.WRD;
				arg   = instr.arg1;
				break;
			case Instruction.writeNL:
				dlxOp = DLX.WRL;
				addInstruction(dlxOp);
				return true;
			default:
				return false;
		}

		int reg = arg.getReg();

		if (arg instanceof Constant) {
			addInstruction(DLX.ADDI, SCRATCH, ZERO, arg.getVal());
			reg = SCRATCH;
		}
		addInstruction(dlxOp, reg);
		return true;
	}
	// Deal with function and procedure calls.
	public void generateFunction(Instruction instr) {
		Function function = instr.getFunction();
		int n = 0;      // Needs to be set to the amount of space needed for locals.
		int params = function.getNumParams() * BYTES_IN_WORD; // Space for params.

		// Procedure prologue
		addInstruction(DLX.PSH, RET_ADDR, SP, - BYTES_IN_WORD); // Store return address.
		addInstruction(DLX.PSH, FP, SP, - BYTES_IN_WORD);       // Store old frame pointer.
		addInstruction(DLX.SUBI, FP, ZERO, BYTES_IN_WORD);      // Set FP = SP.
		addInstruction(DLX.SUBI, SP, SP, n);                    // Reserve space for local vars.

		// Function call (store RP in R31)
		// addInstruction(DLX.JSR, function.firstInstructionAddr());

		// Need to deal with globals, locals, parameters etc...

		// Need to store return value at some point.

		// Procedure epilogue
		addInstruction(DLX.ADD, SP, ZERO, FP);       		           // Set SP = FP.
		addInstruction(DLX.POP, FP, SP, BYTES_IN_WORD);                // Restore frame pointer.
		addInstruction(DLX.POP, RET_ADDR, SP, BYTES_IN_WORD + params); // Restore return address.
		addInstruction(DLX.RET, RET_ADDR);							   // Jump to return address.
	}

	/* Methods to display results. */

	// Generate native program string.
	// Mostly just to look cool because nobody can read it!
	public String byteCodeToString() {
		String result = "";
		for (int instr : byteCode) {
			result += Integer.toBinaryString(instr) + "\n";
		}
		return result;
	}

	// Generate assembly program string.
	public String assemblyToString() {
		String result = "";
		int i = 0;
		int j = 0;
		for (int instr : byteCode) {
			if (dlxOps.get(j).block != null) {
				result += "\nBlock " + dlxOps.get(j).block.shortRepr() + ":\n";
			}
			result +=  String.format("%0$-20s", i + " : " + DLX.disassemble(instr));
			//result +=  i + " : " + DLX.disassemble(instr);
			if (dlxOps.get(j).instr != null) {
				result += " // " + dlxOps.get(j).instr + "\n";
			} else {
				result += "\n";
			}
			i += BYTES_IN_WORD;
			j++;
		}
		return result;
	}

	public String memoryToString() {
		return memoryToString(DLX.MemSize / BYTES_IN_WORD);
	}

	public String memoryToString(int truncate) {
		String result = "Memory \n";
		if (truncate > (DLX.MemSize / BYTES_IN_WORD)) { truncate = (DLX.MemSize / BYTES_IN_WORD); }
		for (int i = 0; i < byteCode.length; i++) {
			result += (i * BYTES_IN_WORD) + " : " + DLX.disassemble(DLX.M[i]);
		}
		for (int i = byteCode.length * BYTES_IN_WORD; i < truncate; i += BYTES_IN_WORD) {
			result += i + " : " + DLX.M[i];
			if (i == DLX.R[GLOBALS]) {
				result += " // Begin global variables";
			}
			if (i == DLX.R[FP]) {
				result += " // FP";
			}
			if (i == DLX.R[SP]) {
				result += " // SP";
			}
			result += "\n";
		}
		return result;
	}

	public String registersToString() {
		String result = "Registers \n";
		for (int i = 0; i < 32; i++) {
			result += "R" + i + " : " + DLX.R[i];
			if (i == ZERO) {
				result += " // Always 0";
			} else if (i == SCRATCH) {
				result += " // Scratch register";
			} else if (i == FP) {
				result += " // FP";
			} else if (i == SP) {
				result += " // SP";
			} else if (i == GLOBALS) {
				result += " // Pointer to globals";
			} else if (i == RET_ADDR) {
				result += " // Pointer to return address";
			}
			result += "\n";
		}
		return result;
	}

	/* Operation codes for intermediate representation. */
	public static final int neg     = Instruction.neg;
	public static final int add     = Instruction.add;
	public static final int sub     = Instruction.sub;
	public static final int mul     = Instruction.mul;
	public static final int div     = Instruction.div;
	public static final int cmp     = Instruction.cmp;

	public static final int adda    = Instruction.adda;
	public static final int load    = Instruction.load;
	public static final int store   = Instruction.store;
	public static final int move    = Instruction.move;
	public static final int phi     = Instruction.phi;

	public static final int end     = Instruction.end;

	public static final int read    = Instruction.read;
	public static final int write   = Instruction.write;
	public static final int writeNL = Instruction.writeNL;

	public static final int bra     = Instruction.bra;
	public static final int bne     = Instruction.bne;
	public static final int beq     = Instruction.beq;
	public static final int bge     = Instruction.bge;
	public static final int blt     = Instruction.blt;
	public static final int bgt     = Instruction.bgt;
	public static final int ble     = Instruction.ble;

	public static final int call    = Instruction.call;
	/* End operation codes. */

	// Translate SSA op codes to DLX op codes.

	int opLookup(int op) {
		switch (op) {
			case neg:
				return DLX.SUB;
			case add:
			  return DLX.ADD;
			case sub:
				return DLX.SUB;
			case mul:
			  return DLX.MUL;
			case div:
				return DLX.DIV;
			case cmp:
			  return DLX.CMP;
			case adda:
			  return DLX.ADD;
			case load:
			  return DLX.LDX;
			case store:
			  return DLX.STX;
			case end:
			  return DLX.RET;
			case read:
			  return DLX.RDI;
			case write:
			  return DLX.WRD;
			case writeNL:
			  return DLX.WRL;
			case bra:
			  return DLX.BEQ;
			case bne:
			  return DLX.BNE;
			case beq:
			  return DLX.BEQ;
			case bge:
			  return DLX.BGE;
			case blt:
			  return DLX.BLT;
			case bgt:
			  return DLX.BGT;
			case ble:
			  return DLX.BLE;
			default:
				Compiler.warning("Operation not found.");
				return -1;
		}
	}

		// Translate SSA op codes to DLX op codes.

		int numArgs(int op) {
			switch (op) {
				case writeNL:
					return 0;

				case end:
				case read:
				case write:
					return 1;

				case load:
				case store:
				case bra:
				case bne:
				case beq:
				case bge:
				case blt:
				case bgt:
				case ble:
					return 2;

				case neg:
				case add:
				case sub:
				case div:
				case cmp:
				case adda:
					return 3;

				default:
					Compiler.warning("Operation not found.");
					return -1;
			}

	}


}
